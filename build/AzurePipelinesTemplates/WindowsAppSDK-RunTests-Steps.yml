parameters:
  buildPlatform: ''
  buildConfiguration: ''
  ImageName: ''
  TaefSelect: '*'
  BinaryCompatSwitch: ''
  testLocale: ''
  SamplesArtifactName: ''
  IsOneBranch: false
  callingStage: ''

steps:
  - task: powershell@2
    displayName: 'DevCheck: Setup/Verify test environment'
    inputs:
      targetType: filePath
      filePath: tools\DevCheck\DevCheck.ps1
      arguments: -NoInteractive -Offline -Verbose -CheckTestPfx -Clean -ShowSystemInfo
      workingDirectory: '$(Build.SourcesDirectory)'

  - task: DownloadPipelineArtifact@2
    displayName: 'Download Foundation'
    inputs:
      source: specific
      runVersion: specific
      project: $(System.TeamProjectId)
      pipeline: $(_useBuildOutputFromPipeline)
      pipelineId: $(_useBuildOutputFromBuildId)
      artifactName: "FoundationBinaries_$(buildConfiguration)_$(buildPlatform)"
      targetPath: '$(Build.SourcesDirectory)\BuildOutput'

  - task: DownloadPipelineArtifact@2
    displayName: 'Download Foundation'
    inputs:
      source: specific
      runVersion: specific
      project: $(System.TeamProjectId)
      pipeline: $(_useBuildOutputFromPipeline)
      pipelineId: $(_useBuildOutputFromBuildId)
      artifactName: "MrtBinaries_$(buildConfiguration)_$(buildPlatform)"
      targetPath: '$(Build.SourcesDirectory)\BuildOutput'

  - task: CopyFiles@2
    displayName: Download published redist files
    inputs:
      SourceFolder: '$(Build.SourcesDirectory)\BuildOutput\redist'
      TargetFolder: '$(Build.SourcesDirectory)\redist'

  - task: powerShell@2
    displayName: 'Enable developer mode'
    inputs:
      targetType: 'inline'
      script: |
            $RegistryKeyPath = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\AppModelUnlock"
            if (-not(Test-Path -Path $RegistryKeyPath))
            {
                New-Item -Path $RegistryKeyPath -ItemType Directory -Force
            }

            New-ItemProperty -Path $RegistryKeyPath -Name AllowDevelopmentWithoutDevLicense -PropertyType DWORD -Value 1 -Force
            reg add HKLM\Software\Policies\Microsoft\Windows\Appx /v AllowDevelopmentWithoutDevLicense /t REG_DWORD /d 1 /f

  - task: powerShell@2
    displayName: 'Install certificates in payload'
    inputs:
      targetType: 'inline'
      script: |
            foreach($cerFile in (Get-ChildItem -Path '$(Build.SourcesDirectory)\BuildOutput' '*.cer' -Recurse))
            {
              Write-Host "Adding cert $($cerFile.FullName)"
              certutil -addstore TrustedPeople $($cerFile.FullName)
              certutil -addstore root $($cerFile.FullName)
            }

  - task: powerShell@2
    displayName: 'Run dotnet installer'
    inputs:
      targetType: 'inline'
      script: |
            $(Build.SourcesDirectory)\redist\dotnet-windowsdesktop-runtime-installer.exe /quiet /install /norestart

  - task: PowerShell@2
    displayName: 'Install VCLibs and VCLibs Desktop'
    inputs:
      filePath: 'build/InstallVCLibs.ps1'
      arguments: >
        -SourceDirectory "$(Build.SourcesDirectory)\BuildOutput\Release"
        -Platform "${{ parameters.buildPlatform }}"

  - task: powerShell@2
    displayName: 'Install vc_redist'
    inputs:
      targetType: 'inline'
      script: |
            $(Build.SourcesDirectory)\redist\vc_redist.${{ parameters.buildPlatform }}.exe /quiet /install /norestart

  - task: powershell@2
    displayName: 'Run TE.Service'
    inputs:
      targetType: filePath
      filePath: tools\DevCheck\DevCheck.ps1
      arguments: -NoInteractive -Offline -Verbose -CheckTAEFService -ShowSystemInfo
      workingDirectory: '$(Build.SourcesDirectory)'

  - task: PowerShell@2
    displayName: Display storage info and init variables
    inputs:
      targetType: 'inline'
      script: |
        Get-WmiObject win32_logicaldisk | Format-Table DeviceId, MediaType, @{n="Size";e={[math]::Round($_.Size/1GB,2)}},@{n="FreeSpace";e={[math]::Round($_.FreeSpace/1GB,2)}}, @{n="UsedSpace";e={[math]::Round((($_.Size-$_.FreeSpace)/1GB),2)}}
        $IsPlatformX86 = (('${{ parameters.buildPlatform }}' -eq 'x86') -or ('${{ parameters.buildPlatform }}' -eq 'X86'))
        Write-Output "##vso[task.setvariable variable=isPlatformX86;isOutput=true]$IsPlatformX86"
        Write-Output "##vso[task.setvariable variable=isPlatformX86]$IsPlatformX86"
        $IsReleaseConfig = (('${{ parameters.buildConfiguration }}' -eq 'release') -or ('${{ parameters.buildConfiguration }}' -eq 'Release'))
        Write-Output "##vso[task.setvariable variable=isReleaseConfig;isOutput=true]$IsReleaseConfig"
        Write-Output "##vso[task.setvariable variable=isReleaseConfig]$IsReleaseConfig"
        Write-Host ${{ parameters.buildPlatform }}, ${{ parameters.buildConfiguration }}, $isPlatformX86, $isReleaseConfig, 'callingStage: ${{ parameters.callingStage }}'
  - ${{  if ne(parameters.samplesArtifactName, '') }}:
    - ${{ each featureAreas in parameters.sampleFeatureAreasList }}:
      - ${{ if parameters.IsOneBranch }}:
        - ${{ each artifactNameSuffix in featureAreas.value }}:
          # If we are downloading for Release config, omit the *debug* specific stuff to save time and storage.
          # If we are running for x86 platform, then don't download Sample app artifacts, as we currently don't build Samples for x86.
          - task: DownloadPipelineArtifact@2
            condition: and(and(succeeded(), ne(variables['isPlatformX86'], 'true')), eq(variables['IsReleaseConfig'], 'true'))
            displayName: 'Download Release ${{ parameters.SamplesArtifactName }}_${{ artifactNameSuffix }}'
            inputs:
              source: specific
              runVersion: specific
              project: $(System.TeamProjectId)
              pipeline: $(_useBuildOutputFromPipeline)
              pipelineId: $(_useBuildOutputFromBuildId)
              artifactName: ${{ parameters.SamplesArtifactName }}_${{ artifactNameSuffix }}
              targetPath: '$(Build.SourcesDirectory)\$(SamplesRepoName)\Samples'
              patterns: |
                **
                !**/*binlog
                !**/*debug*/**/*
      - ${{ if not( parameters.IsOneBranch ) }}:
        - task: DownloadPipelineArtifact@2
          # It is currently by design to _not_ test Sample apps when platform=x86 or config=Debug.
          condition: and(and(succeeded(), ne(variables['isPlatformX86'], 'true')), eq(variables['IsReleaseConfig'], 'true'))
          displayName: 'Download Release ${{ parameters.SamplesArtifactName }}_${{ featureAreas.key }}'
          inputs:
            source: specific
            runVersion: specific
            project: $(System.TeamProjectId)
            pipeline: $(_useBuildOutputFromPipeline)
            pipelineId: $(_useBuildOutputFromBuildId)
            artifactName: ${{ parameters.SamplesArtifactName }}_${{ featureAreas.key }}
            targetPath: '$(Build.SourcesDirectory)\$(SamplesRepoName)\Samples'
            patterns: |
              **
              !**/*binlog
              !**/*debug*/**/*
    # WindowsAppSDKSampleAppTests requires SAMPLES_ROOT_PATH to be set.
    - task: PowerShell@2
      displayName: Set SAMPLES_ROOT_PATH env variable
      condition: and(succeeded(), and(ne(variables['isPlatformX86'], 'true'), eq(variables['IsReleaseConfig'], 'true')))
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "##vso[task.setvariable variable=SAMPLES_ROOT_PATH;isOutput=true]$(Build.SourcesDirectory)\$(SamplesRepoName)\Samples"
          Write-Host "##vso[task.setvariable variable=SAMPLES_ROOT_PATH;]$(Build.SourcesDirectory)\$(SamplesRepoName)\Samples"

  - task: VisualStudioTestPlatformInstaller@1
    inputs:
      versionSelector: latestStable

  - task: PowerShell@2
    displayName: Add test locale to User Language List
    inputs:
      targetType: 'inline'
      script: |
            $langToAdd = "${{ parameters.testLocale }}"

            Write-Host "Adding $langToAdd to user language list"
            $langList = Get-WinUserLanguageList
            $langList.Insert(0, $langToAdd)
            Set-WinUserLanguageList -LanguageList $langList -Force

            Write-Host "Get-WinUserLanguageList:"
            Get-WinUserLanguageList

  - task: PowerShell@2
    displayName: Display OS build/version/language info
    inputs:
      targetType: 'inline'
      script: |
            Get-Item -Path 'HKLM:\Software\Microsoft\Windows NT\CurrentVersion'
            Write-Host (reg query "HKLM\SYSTEM\CurrentControlSet\Control\MUI" /s)
            Write-Host (reg query "HKLM\SYSTEM\CurrentControlSet\Control\Nls" /s)
            Write-Host (reg query "HKCU\Control Panel\International" /s)

            Write-Host "Get-WmiObject -Class Win32_OperatingSystem"
            $OSInfo = Get-WmiObject -Class Win32_OperatingSystem
            $languagePacks = $OSInfo.MUILanguages
            $languagePacks

            Write-Host "dism /online /Get-Intl"
            dism /online /Get-Intl

            Write-Host "Get-WinUserLanguageList"
            Get-WinUserLanguageList

            Write-Host "Get-WinUILanguageOverride"
            Get-WinUILanguageOverride

            Write-Host "Get-WinSystemLocale"
            Get-WinSystemLocale

            Write-Host "WhoAmI"
            Write-Host (whoami /user /groups /priv)

  - task: PowerShell@2
    displayName: 'Dump services'
    inputs:
      targetType: 'inline'
      script: |
        Get-Service
        Get-Service | Write-Host
        Get-Service | Out-Host
        sc.exe queryex te.service | Write-Host
        sc.exe qc te.service | Write-Host

  # For test sample apps, we need to copy the 'net6' subfolder generated by WindowsAppSDK.Test.NetCore.csproj to WindowsAppSDK.Test.SampleTests folder
  - ${{ if eq( parameters.callingStage, 'TestSampleApps' ) }}:
    - task: CopyFiles@2
      displayName: 'Copy net6 output to SampleTests folder'
      inputs:
        SourceFolder: '$(Build.SourcesDirectory)\BuildOutput\$(buildConfiguration)\$(buildPlatform)\WindowsAppSDK.Test.NetCore\net6'
        TargetFolder: '$(Build.SourcesDirectory)\BuildOutput\$(buildConfiguration)\$(buildPlatform)\WindowsAppSDK.Test.SampleTests\net6'
        Contents: '**'
  
  - task: PowerShell@2
    displayName: 'Run TAEF Tests'
    inputs:
      filePath: 'TestAll.ps1'
      arguments: >
        -OutputFolder "$(Build.SourcesDirectory)\BuildOutput"
        -Platform "${{ parameters.buildPlatform }}"
        -Configuration "${{ parameters.buildConfiguration }}"
        -Test
        -List
        -wprProfilePath "$(Build.SourcesDirectory)\WindowsAppSDKConfig\src\test\AppModelProviders.wprp"
        -callingStage "${{ parameters.callingStage }}"

  - template: AzurePipelinesTemplates\WindowsAppSDK-ConvertWttLogToXUnit-Steps.yml@WindowsAppSDKConfig
    parameters:
      WttInputPath: '$(Build.SourcesDirectory)\TestOutput\$(buildConfiguration)\$(buildPlatform)\Te.wtl'
      xunitOutputPath: '$(Build.SourcesDirectory)\TestOutput\$(buildConfiguration)\$(buildPlatform)\testResults-$(buildConfiguration)_$(buildPlatform)_${{ parameters.ImageName }}.xml'
      TestNamePrefix: '$(buildConfiguration)_$(buildPlatform)_${{ parameters.ImageName }}'
      BypassTests: '$(Build.SourcesDirectory)\test\BypassTests.json'
      CheckoutPath: '$(Build.SourcesDirectory)\WindowsAppSDKConfig'

  - task: PublishTestResults@2
    displayName: 'Publish test results'
    condition: succeededOrFailed()
    inputs:
      testResultsFormat: xUnit
      testResultsFiles: testResults-*.xml
      searchFolder: '$(Build.SourcesDirectory)\TestOutput\$(buildConfiguration)\$(buildPlatform)'
      mergeTestResults: true
      failTaskOnFailedTests: true
      testRunTitle: '$(System.StageName)_${{ parameters.ImageName }}_$(buildConfiguration)$(buildPlatform)'
      buildPlatform: ${{ parameters.buildPlatform }}
      buildConfiguration: ${{ parameters.buildConfiguration }}

  - task: PowerShell@2
    displayName: Edit the artifactStatus variable
    condition: succeededOrFailed()
    inputs:
      targetType: 'inline'
      script: |
        $status = '$(Agent.JobStatus)'
        if ($status -eq 'SucceededWithIssues') {
          $status = 'Succeeded'
        }
        Write-Host "##vso[task.setvariable variable=artifactStatus]$status"

  # Edit the artifactAttempt variable when the job has failed, so that the artifact name can be unique.
  - task: PowerShell@2
    displayName: Edit the artifactAttempt variable when the job has failed
    condition: failed()
    inputs:
      targetType: 'inline'
      script: |
        Write-Host "##vso[task.setvariable variable=artifactAttempt]_$(System.JobAttempt)"

  - task: PublishPipelineArtifact@1
    condition: succeededOrFailed()
    inputs:
      targetPath: '$(Build.SourcesDirectory)\TestOutput'
      artifact: '$(System.StageName)_${{ parameters.ImageName }}_$(buildConfiguration)$(buildPlatform)_$(artifactStatus)$(artifactAttempt)'
      Parallel: true
