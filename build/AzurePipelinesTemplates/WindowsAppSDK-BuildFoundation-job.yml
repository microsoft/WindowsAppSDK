parameters:
  - name: "ReleaseSigning"
    type: boolean
    default: False
  - name: "IgnoreFailures"
    type: boolean
    default: False
  - name: "PublishPackage"
    type: boolean
    default: False
  - name: "GenerateSBOM"
    type: boolean
    default: False
  - name: "RunSDLBinaryAnalysis"
    displayName: "Run SDL's Binary Analysis (PREFast, BinSkim)"
    type: boolean
    default: False
  - name: "enablePREFast"
    type: boolean
    default: true
  - name: "enableLicenseInstall"
    type: boolean
    default: true
  - name: "isWeeklyRun"
    type: boolean
    default: False
  - name: "solutionPath"
    type: string
    default: "WindowsAppRuntime.sln"

jobs:
# This relatively low-cost job is always run, in parallel w/ the Build job.
# alam start
# - template: WindowsAppSDK-SourceAnalysis-job.yml
# alam end

- job: VerifyCopyrightHeaders
  dependsOn: []
  pool: ProjectReunionESPool-2022
  # alam start
  condition: false
  # alam end
  steps:
  - task: powershell@2
    displayName: 'Verify copyright headers'
    inputs:
      targetType: filePath
      filePath: tools\VerifyCopyrightHeaders.ps1

- job: Build
  pool: ProjectReunionESPool-2022
  timeoutInMinutes: 120
  strategy:
    maxParallel: 10
    matrix:
      Release_x86:
        buildPlatform: 'x86'
        buildConfiguration: 'Release'
        normalizedConfiguration: 'fre'
        PGOBuildMode: 'Optimize'
      Release_x64:
        buildPlatform: 'x64'
        buildConfiguration: 'Release'
        normalizedConfiguration: 'fre'
        PGOBuildMode: 'Optimize'
      Release_Arm64:
        buildPlatform: 'arm64'
        buildConfiguration: 'Release'
        normalizedConfiguration: 'fre'
  steps:
  # Required by the Packaged ES SDL Templates.
  - checkout: self
    persistCredentials: true

  - task: NuGetToolInstaller@1

  - task: NuGetAuthenticate@1
    inputs:
      nuGetServiceConnections: 'TelemetryInternal'

  - task: 333b11bd-d341-40d9-afcf-b32d5ce6f23b@2
    displayName: 'NuGet restore of packages'
    inputs:
      command: 'custom'
      arguments: 'restore dev\WindowsAppRuntime_Insights\packages.config -ConfigFile NuGet.config -PackagesDirectory dev\WindowsAppRuntime_Insights\packages'


  - template: WindowsAppSDK-SetupBuildEnvironment-Steps.yml

  - task: NuGetAuthenticate@1
    inputs:
      nuGetServiceConnections: 'ProjectReunionInternal'

  - ${{ if eq(parameters.enableLicenseInstall, true) }}:
    # Copy MSIX license installation header into the correct source location.
    # Restore transport package dependencies. This is only enbaled in release-signed builds.
    - task: PowerShell@2
      name: ConvertVersionDetailsToPackageConfig
      displayName: "Convert VersionDetails To PackageConfig"
      inputs:
        filePath: '$(Build.SourcesDirectory)\build\Scripts\ConvertVersionDetailsToPackageConfig.ps1'
        arguments: -versionDetailsPath '$(Build.SourcesDirectory)\eng\Version.Details.xml' -packageConfigPath '$(Build.SourcesDirectory)\build\packages.config'

    - task: 333b11bd-d341-40d9-afcf-b32d5ce6f23b@2
      displayName: RestoreNuGetPackages
      inputs:
        restoreSolution: build/packages.config
        feedsToUse: config
        nugetConfigPath: NuGet.config
        restoreDirectory: packages

    - task: CopyFiles@2
      displayName: 'Extract license header to source location'
      inputs:
        SourceFolder: '$(Build.SourcesDirectory)\build\packages\$(AppLicensingInternalPackageName).$(AppLicensingInternalPackageVersion)\src'
        Contents: |
          *.h
        TargetFolder: '$(Build.SourcesDirectory)\dev\Licensing'
        flattenFolders: false
        overWrite: true

  # Begin forking into 2 code paths: 1) Use BuildAll.ps1 to build the target when _not_ running PREFast, 2) Use the *SBuild task to build the  
  # target when running PREFast.

  - ${{ if and(eq(parameters.RunSDLBinaryAnalysis, 'true'), eq(parameters.EnablePREFast, 'true')) }}:
    # PREFast scan is enabled in this pipeline run, so we pass PreFastSetup to BuildAll.ps1 to get it to do the commonn setup steps, but short of
    # building the target via MSBuild.exe.
    - task: PowerShell@2
      name: PreFastSetup
      inputs:
        filePath: 'BuildAll.ps1'
        arguments: -Platform "$(buildPlatform)" -Configuration "$(buildConfiguration)" -AzureBuildStep "PreFastSetup"

    - powershell: |
        # Some builds have "-branchname" appended, but when this happens the environment variable 
        # TFS_BUILDNUMBER has the un-modified version.
        if ($env:TFS_BUILDNUMBER)
        {
          $env:BUILD_BUILDNUMBER = $env:TFS_BUILDNUMBER
        }
        $yymm = $env:BUILD_BUILDNUMBER.substring($env:BUILD_BUILDNUMBER.length - 10, 4)
        $dd = $env:BUILD_BUILDNUMBER.substring($env:BUILD_BUILDNUMBER.length - 5, 2)
        $revision = $env:BUILD_BUILDNUMBER.substring($env:BUILD_BUILDNUMBER.length - 3, 3)
        Write-Host "##vso[task.setvariable variable=builddate]$yymm$dd"
        Write-Host "##vso[task.setvariable variable=builddate_yymm]$yymm"
        Write-Host "##vso[task.setvariable variable=builddate_dd]$dd"
        Write-Host "##vso[task.setvariable variable=buildrevision]$revision"
        Write-Host builddate=$yymm$dd
        Write-Host builddate_yymm=$yymm
        Write-Host builddate_dd=$dd
        Write-Host buildrevision=$revision
      displayName: 'Get build revision number'

    - script: |
        "%ProgramFiles(x86)%\Microsoft Visual Studio\Installer\vswhere.exe" -Latest -requires Microsoft.Component.MSBuild -property InstallationPath > %TEMP%\vsinstalldir.txt
        set /p _VSINSTALLDIR15=<%TEMP%\vsinstalldir.txt
        del %TEMP%\vsinstalldir.txt
        call "%_VSINSTALLDIR15%\Common7\Tools\VsDevCmd.bat"
        echo VCToolsInstallDir = %VCToolsInstallDir%
        echo ##vso[task.setvariable variable=VCToolsInstallDir]%VCToolsInstallDir%
      displayName: 'Retrieve VC tools directory'

    # The PREFast task only supports the VSBuild/MSbuild task, _not_ a direct call to MSBuild.exe.
    - task: VSBuild@1
      displayName: 'Build solution ${{ parameters.solutionPath }}'
      inputs:
        solution: ${{ parameters.solutionPath }}
        vsVersion: 17.0
        platform: '$(buildPlatform)'
        configuration: '$(buildConfiguration)'
        msbuildArgs: '/restore /p:AppxSymbolPackageEnabled=false /binaryLogger:BuildOutput/${{ parameters.solutionPath }}.$(buildPlatform).$(buildConfiguration).binlog /p:WindowsAppSDKVersionBuild=$(builddate_yymm) /p:WindowsAppSDKVersionRevision=$(builddate_dd)$(buildrevision) /p:VCToolsInstallDir="$(VCToolsInstallDir)\" /p:PGOBuildMode="Optimize" /p:WindowsAppSDKBuildPipeline=1 /p:WindowsAppSDKCleanIntermediateFiles=true'

    # ToDo: This is a workaround for b#43856157. We probably can remove this step once the bug is fixed. 
    - task: UseDotNet@2
      inputs:
        packageType: sdk
        version: '6.x'

  - ${{ if or(ne(parameters.RunSDLBinaryAnalysis, 'true'), ne(parameters.EnablePREFast, 'true')) }}:
    # PREFast scan is disabled in this pipeline run, just proceed to build the target via BuildAll.ps1, and
    # fall through to run BinaryAnalysis with PREFast turned off.
    - task: PowerShell@2
      name: BuildBinaries
      inputs:
        filePath: 'BuildAll.ps1'
        arguments: -Platform "$(buildPlatform)" -Configuration "$(buildConfiguration)" -AzureBuildStep "BuildBinaries"

  # End of forked code paths.

  # component detection must happen *within* the build task
  - task: ms.vss-governance-buildtask.governance-build-task-component-detection.ComponentGovernanceComponentDetection@0

  # Common code for performing Binary Analysis.
  - ${{ if eq(parameters.RunSDLBinaryAnalysis, 'true') }}:
    # Beware that the SDL template downstream from here currently invokes the PREFast task v2, which is out of support.
    # Unlike the case with building MRT Core, the msbuildArgs parameter in the call to the VSBuild task above contains 
    # an escape sequence in /p:VCToolsInstallDir="$(VCToolsInstallDir)\", which tripped PREFast task v3 (this is a known 
    # issue tracked by User Story 2640894: Autofill - fix quoting issues), so a direct call to PREFast task v3 currently
    # fails, hence, we are staying with PREFast task v2 for now.
    - template: WindowsAppSDK-BinaryAnalysis-steps.yml
      parameters:
        outputDirectory: BuildOutput
        enablePREFast: ${{ parameters.EnablePREFast }}

  - ${{ if eq(parameters.GenerateSBOM, 'true') }}:
    - task: AzureArtifacts.manifest-generator-task.manifest-generator-task.ManifestGeneratorTask@0
      displayName: 'SBOM Generation Task'
      inputs:
        BuildDropPath: '$(Build.ArtifactStagingDirectory)\mrt_raw\lib\$(buildPlatform)'

  - task: PublishBuildArtifacts@1
    displayName: 'Publish artifact: Full Nuget'
    inputs:
      PathtoPublish: '$(build.SourcesDirectory)\BuildOutput'
      artifactName: 'BuildOutput'

  - task: PublishBuildArtifacts@1
    displayName: 'Publish artifact: Test dependencies'
    inputs:
      PathtoPublish: '$(build.SourcesDirectory)\packages'
      artifactName: 'packages'

  - task: PublishBuildArtifacts@1
    displayName: 'Publish artifact: Test cert'
    inputs:
      PathtoPublish: '$(build.SourcesDirectory)\.user'
      artifactName: 'TestCert'

- job: BuildAnyCPU
  # For now, this job just builds Microsoft.WindowsAppRuntime.Bootstrap.Net.dll in AnyCPU
  # Can be expanded to add any other binary as needed
  pool: ProjectReunionESPool-2022
  steps:
  - task: NuGetToolInstaller@1
  - task: NuGetAuthenticate@1
    inputs:
      nuGetServiceConnections: 'TelemetryInternal'

  - task: 333b11bd-d341-40d9-afcf-b32d5ce6f23b@2
    displayName: 'NuGet restore of packages'
    inputs:
      command: 'custom'
      arguments: 'restore dev\WindowsAppRuntime_Insights\packages.config -ConfigFile NuGet.config -PackagesDirectory dev\WindowsAppRuntime_Insights\packages'

  - template: WindowsAppSDK-SetupBuildEnvironment-Steps.yml

  - task: PowerShell@2
    name: BuildBinaries
    inputs:
      filePath: 'BuildAll.ps1'
      arguments: -AzureBuildStep "BuildAnyCPU"

  - ${{ if eq(parameters.RunSDLBinaryAnalysis, 'true') }}:
    - template: WindowsAppSDK-BinaryAnalysis-steps.yml
      parameters:
        outputDirectory: BuildOutput
        # Currently, this BuildAnyCPU job does not build any native code, while PREFast supports native C/C++ code only,
        # So to avoid getting the PREFast warning of "found nothing to scan", just skip PREFast for now for cleaner logs.
        enablePREFast: false

  # component detection must happen *within* the build task
  - task: ms.vss-governance-buildtask.governance-build-task-component-detection.ComponentGovernanceComponentDetection@0

  - task: ComponentGovernanceComponentDetection@0
    inputs:
      scanType: 'Register'
      verbosity: 'Verbose'
      alertWarningLevel: 'Medium'
      failOnAlert: true

  - ${{ if eq(parameters.GenerateSBOM, 'true') }}:
    - task: AzureArtifacts.manifest-generator-task.manifest-generator-task.ManifestGeneratorTask@0
      displayName: 'SBOM Generation Task'
      inputs:
        BuildDropPath: '$(Build.ArtifactStagingDirectory)\mrt_raw\lib\$(buildPlatform)'

  - task: PublishBuildArtifacts@1
    displayName: 'Publish artifact: Full Nuget'
    inputs:
      PathtoPublish: '$(build.SourcesDirectory)\BuildOutput'
      artifactName: 'BuildOutput'

- job: BuildAndTestMRT
  pool: ProjectReunionESPool-2022
  timeoutInMinutes: 120
  strategy:
    maxParallel: 10
    matrix:
      Release_x86:
        buildPlatform: 'x86'
        buildConfiguration: 'Release'
        normalizedConfiguration: 'fre'
        PGOBuildMode: 'Optimize'
      Release_x64:
        buildPlatform: 'x64'
        buildConfiguration: 'Release'
        normalizedConfiguration: 'fre'
        PGOBuildMode: 'Optimize'
      Release_Arm64:
        buildPlatform: 'arm64'
        buildConfiguration: 'Release'
        normalizedConfiguration: 'fre'
  steps:
  - task: NuGetToolInstaller@1
  - task: NuGetAuthenticate@1
    inputs:
      nuGetServiceConnections: 'TelemetryInternal'
      
  - task: 333b11bd-d341-40d9-afcf-b32d5ce6f23b@2
    displayName: 'NuGet restore of packages'
    inputs:
      command: 'custom'
      arguments: 'restore dev\WindowsAppRuntime_Insights\packages.config -ConfigFile NuGet.config -PackagesDirectory dev\WindowsAppRuntime_Insights\packages'

  - template: WindowsAppSDK-BuildAndTestMRT-Steps.yml
    parameters:
      EnablePREFast: ${{ parameters.enablePREFast }}
      RunSDLBinaryAnalysis: ${{ parameters.RunSDLBinaryAnalysis }}

  - ${{ if eq(parameters.GenerateSBOM, 'true') }}:
    - task: AzureArtifacts.manifest-generator-task.manifest-generator-task.ManifestGeneratorTask@0
      displayName: 'SBOM Generation Task'
      inputs:
        BuildDropPath: '$(Build.ArtifactStagingDirectory)\mrt_raw\lib\$(buildPlatform)'

  - task: PublishBuildArtifacts@1
    displayName: 'Publish artifact: Full Nuget'
    inputs:
      PathtoPublish: '$(build.SourcesDirectory)\BuildOutput'
      artifactName: 'BuildOutput'

# Arm64 uses a different VM type than x64, thus requiring them to be in different
# pools, hence, we spilt the two scenarios into separate jobs.
# alam start
# - template: WindowsAppSDK-RunTestsInPipeline-Job.yml
#   parameters:
#     jobName: PipelineTestsX64
#     isArm64Platfrom: false
#     dependsOn:
#       - Build
#       - BuildAndTestMRT

# - template: WindowsAppSDK-RunTestsInPipeline-Job.yml
#   parameters:
#     jobName: PipelineTestsArm64
#     isArm64Platfrom: true
#     dependsOn:
#       - Build
#       - BuildAndTestMRT
# alam end

- job: StageAndPack
  pool: ProjectReunionESPool-2022
  timeoutInMinutes: 120      
  dependsOn:
    - Build
    - BuildAnyCPU
    - BuildAndTestMRT
  # alam start
  # condition: or(succeeded(), eq(${{ parameters.IgnoreFailures }}, 'true'))
  condition: false
  # alam end
  steps:
  - task: DownloadBuildArtifacts@0
    inputs:
      artifactName: BuildOutput
      downloadPath: '$(Build.SourcesDirectory)'

  - task: PowerShell@2
    name: StageFiles
    inputs:
      filePath: 'BuildAll.ps1'
      arguments: -Platform "x86,x64,arm64" -Configuration "release" -AzureBuildStep "StageFiles"

  - task: EsrpCodeSigning@2
    inputs:
      ConnectedServiceName: 'Project Reunion ESRP Code Signing Connection'
      FolderPath: '$(Build.SourcesDirectory)\BuildOutput\FullNuget'
      Pattern: |
        **/*.winmd
        **/*.dll
        **/*.exe
      UseMinimatch: true
      signConfigType: 'inlineSignParams'
      inlineOperation: |
        [
          {
            "keyCode": "CP-230012",
            "operationSetCode": "SigntoolSign",
            "parameters": [
              {
                "parameterName": "OpusName",
                "parameterValue": "Microsoft"
              },
              {
                "parameterName": "OpusInfo",
                "parameterValue": "http://www.microsoft.com"
              },
              {
                "parameterName": "PageHash",
                "parameterValue": "/NPH"
              },
              {
                "parameterName": "FileDigest",
                "parameterValue": "/fd sha256"
              },
              {
                "parameterName": "TimeStamp",
                "parameterValue": "/tr \"http://rfc3161.gtm.corp.microsoft.com/TSS/HttpTspServer\" /td sha256"
              }
            ],
            "toolName": "signtool.exe",
            "toolVersion": "6.2.9304.0"
          }
        ]
      SessionTimeout: '60'
      MaxConcurrency: '50'
      MaxRetryAttempts: '5'
    condition:
      eq(${{ parameters.ReleaseSigning }}, true)

  - task: CopyFiles@2
    displayName: 'Copy symbols to artifact staging directory'
    condition: always()
    inputs:
      sourceFolder: $(Build.SourcesDirectory)\BuildOutput\FullNuget
      contents: |
        **\*.pdb
      targetFolder: $(Build.ArtifactStagingDirectory)\symbols

  - task: PublishSymbols@2
    # ToDo: This task currently fails when running in the weekly pipeline due to inability to authenticate into https://app.vssps.visualstudio.com.
    # This issue is deemed unimportant ATM for the weekly pipeline run whose goal is static analysis.
    condition: ne(${{ parameters.isWeeklyRun }}, 'true')
    displayName: 'Publish private symbols to internal server (without source indexing)'
    inputs:
      searchPattern: '$(Build.ArtifactStagingDirectory)\symbols\**\*.pdb'
      symbolServerType: 'TeamServices'
    # This ADO task does not support indexing of github sources currently :-(
      indexSources: false
      detailedLog: true
    # There is a bug which causes this task to fail if LIB includes an inaccessible path (even though it does not depend on it).
    # To work around this issue, we just force LIB to be any dir that we know exists.
    env:
      LIB: $(Build.SourcesDirectory)

  - task: PublishSymbols@2
    # ToDo: This task currently fails when running in the weekly pipeline due to inability to authenticate into https://app.vssps.visualstudio.com.
    # This issue is deemed unimportant ATM for the weekly pipeline run whose goal is static analysis.
    condition: ne(${{ parameters.isWeeklyRun }}, 'true')
    displayName: 'Publish symbols to public server(without source indexing)'
    inputs:
      searchPattern: '$(Build.ArtifactStagingDirectory)\symbols\**\*.pdb'
      symbolServerType: 'TeamServices'
    # This ADO task does not support indexing of github sources currently :-(
      indexSources: false
      detailedLog: true
    # There is a bug which causes this task to fail if LIB includes an inaccessible path (even though it does not depend on it).
    # To work around this issue, we just force LIB to be any dir that we know exists.
    env:
      LIB: $(Build.SourcesDirectory)
      ArtifactServices_Symbol_AccountName: microsoftpublicsymbols
      ArtifactServices_Symbol_PAT: $(WinSDKLab_microsoftpublicsymbols_PAT)

  - task: PowerShell@2
    name: SetVersion
    displayName: Update metapackage version
    inputs:
      targetType: 'inline'
      script: |
        $packageVersion = '$(version)'
        $pipelineType = '$(PipelineType)'
        $sourceBranchName = '$(Build.SourceBranchName)'
        if ($sourceBranchName -eq 'main' -or $sourceBranchName -eq 'develop')
        {
          $packageVersion = $packageVersion + '.' + $sourceBranchName + '.' + $pipelineType
        }
        Write-Host "##vso[task.setvariable variable=packageVersion;]$packageVersion"
        Write-Host "##vso[task.setvariable variable=packageVersion;isOutput=true;]$packageVersion"
        Write-Host $packageVersion
        [xml]$publicNuspec = Get-Content -Path $(Build.SourcesDirectory)\build\NuSpecs\Microsoft.WindowsAppSDK.Foundation.nuspec
        $publicNuspec.package.metadata.version = $packageVersion
        Set-Content -Value $publicNuspec.OuterXml $(Build.SourcesDirectory)\build\NuSpecs\Microsoft.WindowsAppSDK.Foundation.nuspec

  - task: PowerShell@2
    name: PackNuget
    inputs:
      filePath: 'BuildAll.ps1'
      arguments: -Platform "x64" -Configuration "release" -AzureBuildStep "PackNuget" -OutputDirectory "$(build.artifactStagingDirectory)\FullNuget" -PackageVersion "$(packageVersion)"

  - task: EsrpCodeSigning@2
    inputs:
      ConnectedServiceName: 'Project Reunion ESRP Code Signing Connection'
      FolderPath: $(build.artifactStagingDirectory)\FullNuget
      Pattern: 'Microsoft.WindowsAppSDK.Foundation*.nupkg'
      UseMinimatch: true
      signConfigType: 'inlineSignParams'
      inlineOperation: |
        [
          {
            "KeyCode" : "CP-401405",
            "OperationCode" : "NuGetSign",
            "Parameters" : {},
            "ToolName" : "sign",
            "ToolVersion" : "1.0"
          },
          {
              "KeyCode" : "CP-401405",
              "OperationCode" : "NuGetVerify",
              "Parameters" : {},
              "ToolName" : "sign",
              "ToolVersion" : "1.0"
          }
        ]
      SessionTimeout: '60'
      MaxConcurrency: '50'
      MaxRetryAttempts: '5'
    condition:
        eq(${{ parameters.ReleaseSigning }}, true)

  - task: PublishBuildArtifacts@1
    displayName: 'Publish artifact: NugetContent'
    inputs:
      PathtoPublish: '$(Build.SourcesDirectory)\BuildOutput\FullNuget'
      artifactName: 'NugetContent'

  - task: PublishBuildArtifacts@1
    displayName: 'Publish artifact: TransportPackage'
    inputs:
      PathtoPublish: '$(build.artifactStagingDirectory)\FullNuget'
      artifactName: 'TransportPackage'

# Build WinAppSDK and Run Integration Test from TestAll.ps1
- job: WinAppSDKIntegrationBuildAndTest
  dependsOn: ['StageAndPack']
  # alam start
  # condition: succeeded()
  condition: false
  # alam end
  pool: ProjectReunionESPool-2022
  variables:
    WindowsAppSDKTransportPackageVersion: $[ dependencies.StageAndPack.outputs['SetVersion.packageVersion'] ]
    VersionWithDevTag: $[format('{0}.{1}.{2}-{3}.{4}.{5}', variables['major'], variables['minor'], variables['patch'], 'dev', variables['versionDate'], variables['versionCounter'])]
  steps:
    #TODO: Remove the two template calls once Add-AppxPackage has been resolved
    - template: ..\..\eng\common\AzurePipelinesTemplates\WindowsAppSDK-BuildSetup-Steps.yml
      parameters:
        AzureSubscriptionServiceConnection: 'ProjectReunion Resource Manager'
        NuGetServiceConnectionName: 'ProjectReunionInternal'

    - template: ..\..\eng\common\AzurePipelinesTemplates\WindowsAppSDK-Build-Steps.yml
      parameters:
        TransportPackageArtifactName: 'TransportPackage'
        WindowsAppSDKPackageVersion: $(VersionWithDevTag)
        BuildType:  'stable'
        TransportPackages: 
          FoundationPackage:
            Name: Microsoft.WindowsAppSDK.Foundation.TransportPackage
            Version: $(WindowsAppSDKTransportPackageVersion)
    # TODO: Reenable, Add-AppxPackage currently does not work on 2022 images. See issue #2908
    # - template: ..\..\eng\common\WindowsAppSDK-BuildAndIntegrationTest-Steps.yml
    #   parameters:
    #     WindowsAppSDKPackageVersion: $(VersionWithDevTag)
    #     TestSelection: '*Foundation_*'
    #     TransportPackageArtifactName: 'FullNuget'
    #     BuildType: 'stable'
    #     TransportPackages: 
    #       FoundationPackage:
    #         Name: Microsoft.WindowsAppSDK.Foundation.TransportPackage
    #         Version: $(WindowsAppSDKTransportPackageVersion)

# Publish
- job: Publish
  dependsOn: 
  - StageAndPack
  - WinAppSDKIntegrationBuildAndTest
  # alam start
  # condition: or(succeeded(), eq(${{ parameters.IgnoreFailures }}, 'true'))
  condition: false
  # alam end
  pool: ProjectReunionESPool-2022
  variables:
    WindowsAppSDKPackageVersion: $[ dependencies.StageAndPack.outputs['SetVersion.packageVersion'] ]
  steps:
    - task: DownloadBuildArtifacts@0
      inputs:
        artifactName: TransportPackage
        downloadPath: '$(Build.artifactStagingDirectory)'
        itemPattern: |
          **/*.nupkg

    - ${{ if or(eq(variables['Build.Reason'], 'Schedule'), eq(parameters.PublishPackage, 'true')) }}:
      # this mysterious guid fixes the "NuGetCommand@2 is ambiguous" error :-(
      - task: 333b11bd-d341-40d9-afcf-b32d5ce6f23b@2
        displayName: 'NuGet push to ProjectReunion.nuget.internal'
        inputs:
          command: 'push'
          packagesToPush: '$(Build.artifactStagingDirectory)/TransportPackage/*.nupkg;!$(Build.artifactStagingDirectory)/TransportPackage/*.symbols.nupkg'
          verbosityPush: 'Detailed'
          nuGetFeedType: 'internal'
          #Note: The project qualifier is always required when using a feed name. Also, do not use organization scoped feeds.
          publishVstsFeed: 'ProjectReunion/Project.Reunion.nuget.internal'

      - template: ..\..\eng\common\AzurePipelinesTemplates\Maestro-PublishBuildToMaestro-Steps.yml
        parameters:
          AssetNames: 'Microsoft.WindowsAppSDK.Foundation.TransportPackage'
          AssetVersions: $(WindowsAppSDKPackageVersion)
          TriggerSubscription: true
