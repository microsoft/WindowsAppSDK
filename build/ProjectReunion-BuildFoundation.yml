name: $(BuildDefinitionName)_$(date:yyMM).$(date:dd)$(rev:rrr)
variables:
- template: WindowsAppSDK-Versions.yml
- template: WindowsAppSDK-CommonVariables.yml
- name: buildPool
  value: 'ProjectReunionESPool-2022'

parameters:
  - name: "ReleaseSigning"
    type: boolean
    default: False
  - name: "IgnoreFailures"
    type: boolean
    default: False
  - name: "PublishPackage"
    type: boolean
    default: False
  - name: "GenerateSBOM"
    type: boolean
    default: False
  - name: "RunSDLBinaryAnalysis"
    displayName: "Run SDL's Binary Analysis (PREFast, BinSkim)"
    type: boolean
    default: False
  - name: "enablePREFast"
    type: boolean
    default: true
  - name: "enableLicenseInstall"
    type: boolean
    default: true

resources:
  repositories:
  - repository: templates_onebranch
    type: git
    name: OneBranch.Pipelines/GovernedTemplates
    ref: refs/heads/main

jobs:
# # This relatively low-cost job is always run, in parallel w/ the Build job.
# - template: AzurePipelinesTemplates\WindowsAppSDK-SourceAnalysis-job.yml

# - job: VerifyCopyrightHeaders
#   dependsOn: []
#   pool: ProjectReunionESPool-2022
#   steps:
#   - task: powershell@2
#     displayName: 'Verify copyright headers'
#     inputs:
#       targetType: filePath
#       filePath: tools\VerifyCopyrightHeaders.ps1

- job: Build
  # dependsOn:
  #   - VerifyCopyrightHeaders
  # Skip the build job if we are reusing the output of a previous build.
  # useBuildOutputFromBuildId variable is set on the Pipeline at Queue time.
  # condition: |
  #   and
  #   (
  #     eq(variables['useBuildOutputFromBuildId'],''),
  #     in(dependencies.VerifyCopyrightHeaders.result, 'Succeeded')
  #   )
  pool: ProjectReunionESPool-2022
  timeoutInMinutes: 120
  strategy:
    maxParallel: 10
    matrix:
      Release_x86:
        buildPlatform: 'x86'
        buildConfiguration: 'Release'
        normalizedConfiguration: 'fre'
        PGOBuildMode: 'Optimize'
      Release_x64:
        buildPlatform: 'x64'
        buildConfiguration: 'Release'
        normalizedConfiguration: 'fre'
        PGOBuildMode: 'Optimize'
      Release_Arm64:
        buildPlatform: 'arm64'
        buildConfiguration: 'Release'
        normalizedConfiguration: 'fre'
  steps:
  - template: AzurePipelinesTemplates\WindowsAppSDK-SetupBuildEnvironment-Steps.yml

  - task: NuGetAuthenticate@1
    inputs:
      nuGetServiceConnections: 'ProjectReunionInternal'

  - ${{ if eq(parameters.enableLicenseInstall, true) }}:
    # Copy MSIX license installation header into the correct source location.
    # Restore transport package dependencies. This is only enbaled in release-signed builds.
    - task: PowerShell@2
      name: ConvertVersionDetailsToPackageConfig
      displayName: "Convert VersionDetails To PackageConfig"
      inputs:
        filePath: '$(Build.SourcesDirectory)\build\Scripts\ConvertVersionDetailsToPackageConfig.ps1'
        arguments: -versionDetailsPath '$(Build.SourcesDirectory)\eng\Version.Details.xml' -packageConfigPath '$(Build.SourcesDirectory)\build\packages.config'

    - task: 333b11bd-d341-40d9-afcf-b32d5ce6f23b@2
      displayName: RestoreNuGetPackages
      inputs:
        restoreSolution: build/packages.config
        feedsToUse: config
        nugetConfigPath: build/licensing.nuget.config
        restoreDirectory: packages

    - task: CopyFiles@2
      displayName: 'Extract license header to source location'
      inputs:
        SourceFolder: '$(Build.SourcesDirectory)\build\packages\$(AppLicensingInternalPackageName).$(AppLicensingInternalPackageVersion)\src'
        Contents: |
          *.h
        TargetFolder: '$(Build.SourcesDirectory)\dev\Licensing'
        flattenFolders: false
        overWrite: true

  - task: PowerShell@2
    name: BuildBinaries
    inputs:
      filePath: 'BuildTransportPackage.ps1'
      arguments: -Platform "$(buildPlatform)" -Configuration "$(buildConfiguration)" -AzureBuildStep "BuildBinaries"

  - ${{ if eq(parameters.runSDLBinaryAnalysis, 'true') }}:
    - template: AzurePipelinesTemplates\WindowsAppSDK-BinaryAnalysis-steps.yml
      parameters:
        outputDirectory: BuildOutput
        enablePREFast: ${{ parameters.enablePREFast }}

  - task: PublishBuildArtifacts@1
    displayName: 'Publish artifact: Full Nuget'
    inputs:
      PathtoPublish: '$(build.SourcesDirectory)\BuildOutput'
      artifactName: 'BuildOutput'

- job: BuildAnyCPU
  # For now, this job just builds Microsoft.WindowsAppRuntime.Bootstrap.Net.dll in AnyCPU
  # Can be expanded to add any other binary as needed
  pool: ProjectReunionESPool-2022
  steps:
  - template: AzurePipelinesTemplates\WindowsAppSDK-SetupBuildEnvironment-Steps.yml

  - task: PowerShell@2
    name: BuildBinaries
    inputs:
      filePath: 'BuildTransportPackage.ps1'
      arguments: -AzureBuildStep "BuildAnyCPU"

  - ${{ if eq(parameters.runSDLBinaryAnalysis, 'true') }}:
    - template: AzurePipelinesTemplates\WindowsAppSDK-BinaryAnalysis-steps.yml
      parameters:
        outputDirectory: BuildOutput
        enablePREFast: ${{ parameters.enablePREFast }}

  - task: PublishBuildArtifacts@1
    displayName: 'Publish artifact: Full Nuget'
    inputs:
      PathtoPublish: '$(build.SourcesDirectory)\BuildOutput'
      artifactName: 'BuildOutput'

- template: AzurePipelinesTemplates\WindowsAppSDK-RunHelixTests-Job.yml
  parameters:
    name: 'TestFoundation'
    dependsOn:
      - Build
      - BuildAnyCPU
    condition: in(dependencies.Build.result, 'Succeeded', 'SucceededWithIssues')

- job: BuildAndTestMRT
  pool: ProjectReunionESPool-2022
  timeoutInMinutes: 120
  strategy:
    maxParallel: 10
    matrix:
      Release_x86:
        buildPlatform: 'x86'
        buildConfiguration: 'Release'
        normalizedConfiguration: 'fre'
        PGOBuildMode: 'Optimize'
      Release_x64:
        buildPlatform: 'x64'
        buildConfiguration: 'Release'
        normalizedConfiguration: 'fre'
        PGOBuildMode: 'Optimize'
      Release_Arm64:
        buildPlatform: 'arm64'
        buildConfiguration: 'Release'
        normalizedConfiguration: 'fre'
  steps:
  - template: AzurePipelinesTemplates\WindowsAppSDK-SetupBuildEnvironment-Steps.yml

  - task: PowerShell@2
    name: BuildBinaries
    inputs:
      filePath: 'BuildTransportPackage.ps1'
      arguments: -Platform "$(buildPlatform)" -Configuration "$(buildConfiguration)" -AzureBuildStep "BuildMRT"

  - task: PublishBuildArtifacts@1
    displayName: 'Publish mrtcore binlog'
    condition: succeededOrFailed()
    inputs:
      PathtoPublish: $(Build.SourcesDirectory)/mrtcore.$(buildPlatform).$(buildConfiguration).binlog
      artifactName: binlogs

  # Run the test locally on the Azure VM.
  - task: VSTest@2
    displayName: 'test MRT: ManagedTests'
    condition: and(succeeded(), or(eq(variables['buildPlatform'], 'x86'), eq(variables['buildPlatform'], 'x64')))
    inputs:
      testSelector: 'testAssemblies'
      testAssemblyVer2: '**\MrtCoreManagedTest.build.appxrecipe'
      searchFolder: 'BuildOutput\$(buildConfiguration)\$(buildPlatform)\MrtCoreManagedTest'
      testRunTitle: 'test MRT: ManagedTests - $(buildPlatform)'
      platform: '$(buildPlatform)'
      configuration: '$(buildConfiguration)'

  - task: VSTest@2
    displayName: 'test MRT: UnitTests'
    condition: and(succeeded(), or(eq(variables['buildPlatform'], 'x86'), eq(variables['buildPlatform'], 'x64')))
    inputs:
      testSelector: 'testAssemblies'
      testAssemblyVer2: '**\MrmUnitTest.dll'
      searchFolder: 'BuildOutput\$(buildConfiguration)\$(buildPlatform)\MrmUnitTest'
      testRunTitle: 'test MRT: UnitTests - $(buildPlatform)'
      platform: '$(buildPlatform)'
      configuration: '$(buildConfiguration)'

  - task: VSTest@2
    displayName: 'test MRT: BaseUnitTests'
    condition: and(succeeded(), or(eq(variables['buildPlatform'], 'x86'), eq(variables['buildPlatform'], 'x64')))
    inputs:
      testSelector: 'testAssemblies'
      testAssemblyVer2: '**\MrmBaseUnitTests.dll'
      searchFolder: 'BuildOutput\$(buildConfiguration)\$(buildPlatform)\MrmBaseUnitTests'
      testRunTitle: 'test MRT: BaseUnitTests - $(buildPlatform)'
      platform: '$(buildPlatform)'
      configuration: '$(buildConfiguration)'

  - task: VSTest@2
    displayName: 'test MRT: UnpackagedTests'
    condition: and(succeeded(), or(eq(variables['buildPlatform'], 'x86'), eq(variables['buildPlatform'], 'x64')))
    inputs:
      testSelector: 'testAssemblies'
      testAssemblyVer2: '**\MRTCoreUnpackagedTests.dll'
      searchFolder: 'BuildOutput\$(buildConfiguration)\$(buildPlatform)\MrtCoreUnpackagedTests'
      testRunTitle: 'test MRT: UnpackagedTests - $(buildPlatform)'
      platform: '$(buildPlatform)'
      configuration: '$(buildConfiguration)'

  - ${{ if eq(parameters.runSDLBinaryAnalysis, 'true') }}:
    - template: AzurePipelinesTemplates\WindowsAppSDK-BinaryAnalysis-steps.yml
      parameters:
        outputDirectory: 'BuildOutput'
        enablePREFast: ${{ parameters.enablePREFast }}

  - task: PublishBuildArtifacts@1
    displayName: 'Publish artifact: Full Nuget'
    inputs:
      PathtoPublish: '$(build.SourcesDirectory)\BuildOutput'
      artifactName: 'BuildOutput'


- job: StageAndPack
  pool: ProjectReunionESPool-2022
  timeoutInMinutes: 120
  dependsOn:
  - Build
  - BuildAnyCPU
  steps:
  - task: DownloadBuildArtifacts@0
    inputs:
      artifactName: BuildOutput
      downloadPath: '$(Build.SourcesDirectory)'

  - task: PowerShell@2
    name: StageFiles
    inputs:
      filePath: 'BuildTransportPackage.ps1'
      arguments: -Platform "x86,x64,arm64" -Configuration "release" -AzureBuildStep "StageFiles"

  - task: EsrpCodeSigning@1
    inputs:
      ConnectedServiceName: 'Project Reunion ESRP Code Signing Connection'
      FolderPath: '$(Build.SourcesDirectory)\BuildOutput\FullNuget'
      Pattern: |
        **/*.winmd
        **/*.dll
        **/*.exe
      UseMinimatch: true
      signConfigType: 'inlineSignParams'
      inlineOperation: |
        [
          {
            "keyCode": "CP-230012",
            "operationSetCode": "SigntoolSign",
            "parameters": [
              {
                "parameterName": "OpusName",
                "parameterValue": "Microsoft"
              },
              {
                "parameterName": "OpusInfo",
                "parameterValue": "http://www.microsoft.com"
              },
              {
                "parameterName": "PageHash",
                "parameterValue": "/NPH"
              },
              {
                "parameterName": "FileDigest",
                "parameterValue": "/fd sha256"
              },
              {
                "parameterName": "TimeStamp",
                "parameterValue": "/tr \"http://rfc3161.gtm.corp.microsoft.com/TSS/HttpTspServer\" /td sha256"
              }
            ],
            "toolName": "signtool.exe",
            "toolVersion": "6.2.9304.0"
          }
        ]
      SessionTimeout: '60'
      MaxConcurrency: '50'
      MaxRetryAttempts: '5'
    condition:
      eq(${{ parameters.ReleaseSigning }}, true)

  - task: PowerShell@2
    name: SetVersion
    displayName: Update metapackage version
    inputs:
      targetType: 'inline'
      script: |
        $packageVersion = '$(version)'
        $pipelineType = '$(PipelineType)'
        $sourceBranchName = '$(Build.SourceBranchName)'
        if ($sourceBranchName -eq 'main' -or $sourceBranchName -eq 'develop')
        {
          $packageVersion = $packageVersion + '.' + $sourceBranchName + '.' + $pipelineType
        }
        Write-Host "##vso[task.setvariable variable=packageVersion;]$packageVersion"
        Write-Host $packageVersion
        [xml]$publicNuspec = Get-Content -Path $(Build.SourcesDirectory)\build\NuSpecs\Microsoft.WindowsAppSDK.Foundation.nuspec
        $publicNuspec.package.metadata.version = $packageVersion
        Set-Content -Value $publicNuspec.OuterXml $(Build.SourcesDirectory)\build\NuSpecs\Microsoft.WindowsAppSDK.Foundation.nuspec

  - task: PowerShell@2
    name: PackNuget
    inputs:
      filePath: 'BuildTransportPackage.ps1'
      arguments: -Platform "x64" -Configuration "release" -AzureBuildStep "PackNuget" -OutputDirectory "$(build.artifactStagingDirectory)\FullNuget" -PackageVersion "$(packageVersion)"

  - task: EsrpCodeSigning@1
    inputs:
      ConnectedServiceName: 'Project Reunion ESRP Code Signing Connection'
      FolderPath: $(build.artifactStagingDirectory)\FullNuget
      Pattern: 'Microsoft.WindowsAppSDK.Foundation*.nupkg'
      UseMinimatch: true
      signConfigType: 'inlineSignParams'
      inlineOperation: |
        [
          {
            "KeyCode" : "CP-401405",
            "OperationCode" : "NuGetSign",
            "Parameters" : {},
            "ToolName" : "sign",
            "ToolVersion" : "1.0"
          },
          {
              "KeyCode" : "CP-401405",
              "OperationCode" : "NuGetVerify",
              "Parameters" : {},
              "ToolName" : "sign",
              "ToolVersion" : "1.0"
          }
        ]
      SessionTimeout: '60'
      MaxConcurrency: '50'
      MaxRetryAttempts: '5'

  - task: PublishBuildArtifacts@1
    displayName: 'Publish artifact: Full Nuget'
    inputs:
      PathtoPublish: '$(build.artifactStagingDirectory)\FullNuget'
      artifactName: 'TransportPackage'

# # Publish
# - job: Publish
#   dependsOn: 
#   - CreateNugetPackage
#   # - WinAppSDKIntegrationBuildAndTest
#   condition: or(succeeded(), eq(${{ parameters.IgnoreFailures }}, 'true'))
#   pool: ProjectReunionESPool-2022
#   variables:
#     WindowsAppSDKPackageVersion: $[ dependencies.CreateNugetPackage.outputs['SetVersion.packageVersion'] ]
#   steps:
#     - task: DownloadBuildArtifacts@0
#       inputs:
#         artifactName: FullNuget
#         downloadPath: '$(Build.SourcesDirectory)'
#         itemPattern: |
#           **/*.nupkg

#     - ${{ if or(eq(variables['Build.Reason'], 'Schedule'), eq(parameters.PublishPackage, 'true')) }}:
#       # this mysterious guid fixes the "NuGetCommand@2 is ambiguous" error :-(
#       - task: 333b11bd-d341-40d9-afcf-b32d5ce6f23b@2
#         displayName: 'NuGet push to ProjectReunion.nuget.internal'
#         inputs:
#           command: 'push'
#           packagesToPush: '$(Build.SourcesDirectory)/FullNuget/*.nupkg;!$(Build.SourcesDirectory)/FullNuget/*.symbols.nupkg'
#           verbosityPush: 'Detailed'
#           nuGetFeedType: 'internal'
#           #Note: The project qualifier is always required when using a feed name. Also, do not use organization scoped feeds.
#           publishVstsFeed: 'ProjectReunion/Project.Reunion.nuget.internal'

#       - template: ..\eng\common\AzurePipelinesTemplates\Maestro-PublishBuildToMaestro-Steps.yml
#         parameters:
#           AssetNames: 'Microsoft.WindowsAppSDK.Foundation.TransportPackage'
#           AssetVersions: $(WindowsAppSDKPackageVersion)
#           TriggerSubscription: true
